// ________________________________________________________________________________________________
// import section
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


// ________________________________________________________________________________________________
// directive section
parser code {:
	boolean errorDetected = false;
	Logger logger = Logger.getLogger( getClass() );
   
    // redefine cup parser methods for error reporting
    public void report_fatal_error( String message, Object info ) throws java.lang.Exception
    {
        done_parsing();
        report_error( message, info );
    }
  
    // redefine cup parser methods for error reporting
    public void syntax_error( Symbol cur_token )
    {
        report_error( "\nSintaksna greska", cur_token );
    }
  
    // redefine cup parser methods for error reporting
    public void unrecovered_syntax_error( Symbol cur_token ) throws java.lang.Exception
    {
        report_fatal_error( "Fatalna greska, parsiranje se ne moze nastaviti", cur_token );
    }

    // redefine cup parser methods for error reporting
    public void report_error( String message, Object info )
    {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder( message );

    	if( info instanceof Symbol )
        {
            msg.append( " na liniji " ).append( ( ( Symbol )info ).left );
        }

        logger.error( msg.toString() );
    }
    
    // redefine cup parser methods for error reporting
    public void report_info( String message, Object info )
    {
    	StringBuilder msg = new StringBuilder( message ); 

    	if( info instanceof Symbol )
        {
            msg.append( " na liniji " ).append( ( ( Symbol )info ).left );
        }

        logger.info( msg.toString() );
    }
    
:}

scan with {:
	Symbol symbol = this.getScanner().next_token();
	if( symbol != null && symbol.value != null )
    {
		logger.info( symbol.toString() + " " + symbol.value.toString() );
    }

	return symbol;
:}





// ________________________________________________________________________________________________
// language characters


// keywords [terminals]
terminal PROGRAM_K, CLASS_K, /*ENUM_K,*/ EXTENDS_K;   // enum currently not used
terminal CONST_K, VOID_K;
terminal IF_K, ELSE_K, SWITCH_K, CASE_K, BREAK_K, CONTINUE_K, RETURN_K;
terminal DO_K, WHILE_K;
terminal NEW_K, PRINT_K, READ_K;

// operators [terminals]
//       +     -      *    /    %
terminal plus, minus, mul, div, perc;
//       ==  !=   >   >=   <   <=   &&   ||
terminal eq, neq, gt, geq, lt, leq, and, or;
//       =       ++        --
terminal assign, plusplus, minusminus;
//       ;        ,      .    {       }       (       )       [         ]         ?      :
terminal semicol, comma, dot, lbrace, rbrace, lparen, rparen, lbracket, rbracket, qmark, colon;

// literals [terminals]
terminal Integer int_lit;      // 0   10   12012
terminal Boolean bool_lit;     // true   false
terminal Character char_lit;   // 'a'   '-'

// identifiers [terminals]
terminal String ident;         // asdf0_13



// declarations [nonterminals]
nonterminal Program, StaticDeclList, StaticDecl;
nonterminal ClassDecl, ClassDeclScope, MethodDeclScope, MethodDeclList;
nonterminal MethodDecl, FormPars, FormParsNext, VarDeclList;
nonterminal VarDecl, VarIdentList;
nonterminal ConstDecl, IdentInitList;

// statement parts [nonterminals]
nonterminal Statement, DesignatorStatement;
nonterminal StatementList, CaseList, ActPars, ActParsNext;
nonterminal Condition, CondTerm, CondFact;
nonterminal Expr, Addition, SignedAddition;
nonterminal Term, Factor;
nonterminal Designator, DesignatorNext;

// types, literals, operators [nonterminals]
nonterminal VarIdent, Literal, ReturnType, Type;
nonterminal Assignop, Relop, Addop, Mulop;



// associativity [terminals]
precedence left ELSE_K;        // left associative operation => 'else' is paired with the closest left 'if'

// starting non-terminal
start with Program;





// ________________________________________________________________________________________________
// language rules


// program ident { }
// program ident { method method method }
// program ident constdl constdl vardl vardl classdl { }
// program ident constdl constdl vardl vardl classdl { method method method }
Program ::= (Program) PROGRAM_K ident StaticDeclList MethodDeclScope;

// <epsilon>
// constdl constdl vardl vardl classdl
StaticDeclList ::= (StaticDeclListTail ) StaticDecl StaticDeclList;
StaticDeclList ::= (StaticDeclListEmpty) ;

StaticDecl ::= (StaticDeclConst) ConstDecl;
StaticDecl ::= (StaticDeclVar  ) VarDecl;
StaticDecl ::= (StaticDeclClass) ClassDecl;



// class A { }
// class A { { method method method } }
// class A extends B { vardl vardl vardl vardl }
// class A extends B { vardl vardl vardl vardl { method method method } }
ClassDecl ::= (ClassDecl       ) CLASS_K ident ClassDeclScope;
ClassDecl ::= (ClassExtendsDecl) CLASS_K ident EXTENDS_K Type ClassDeclScope;

// { }
// { { method method method } }
// { vardl vardl vardl vardl }
// { vardl vardl vardl vardl { method method method } }
ClassDeclScope ::= (ClassDeclScope       ) lbrace VarDeclList rbrace;
ClassDeclScope ::= (ClassDeclScopeMethods) lbrace VarDeclList MethodDeclScope rbrace;

// { }
// { method method method }
MethodDeclScope ::= (MethodDeclScope) lbrace MethodDeclList rbrace;

MethodDeclList ::= (MethodDeclListTail ) MethodDecl MethodDeclList;
MethodDeclList ::= (MethodDeclListEmpty) ;



// void foo() { }
// void foo() { statement statement }
// void foo() vardl vardl { }
// void foo() vardl vardl { statement statement }
// void foo( int a, char c, Node Array[] ) { }
// void foo( int a, char c, Node Array[] ) { statement statement }
// void foo( int a, char c, Node Array[] ) vardl vardl { }
// void foo( int a, char c, Node Array[] ) vardl vardl { statement statement }
MethodDecl ::= (MethodDecl) ReturnType ident lparen FormPars rparen VarDeclList lbrace StatementList rbrace;

// <epsilon>
// int ident, Node Array[], char c
FormPars ::= (FormPars     ) Type VarIdent FormParsNext;
FormPars ::= (FormParsEmpty) ;

FormParsNext ::= (FormParsNextFormPar) comma Type VarIdent FormPars;
FormParsNext ::= (FormParsNextEmpty  ) ;

// <epsilon>
// vardl vardl vardl vardl
VarDeclList ::= (VarDeclListVarDecl) VarDecl VarDeclList;
VarDeclList ::= (VarDeclListEmpty  ) ;



// int a, b[], c;
// A a1, a2;
VarDecl ::= (VarDecl) Type VarIdentList semicol;

VarIdentList ::= (VarIdentListVarIdent) VarIdent;
VarIdentList ::= (VarIdentListTail    ) VarIdent comma VarIdentList;



// const int a = 5, b = 6, c = 11;
ConstDecl ::= (ConstDecl) CONST_K Type IdentInitList semicol;

IdentInitList ::= (IdentInitListInit) ident Assignop Literal;
IdentInitList ::= (IdentInitListTail) ident Assignop Literal comma IdentInitList;



// ident.ident[ expr ] = expr;
// ident.ident[ expr ]( );
// ident.ident[ expr ]( expr, expr, expr );
// ident.ident[ expr ]++;
// ident.ident[ expr ]--;
//
// if( condition ) statement
// if( condition ) statement else statement
// do statement while( condition );
// switch( expr ) { }
// switch( expr ) { case 1: statement statement statement   case 2: statement statement }
// break;
// continue;
// return;
// return expr;
//
// read( ident.ident[ expr ] );
// print( ident.ident[ expr ], 2 );
//
// {}
// { statement statement statement }
Statement ::= (StatementDesignator ) DesignatorStatement semicol;
Statement ::= (StatementIf         ) IF_K lparen Condition rparen Statement;
Statement ::= (StatementIfElse     ) IF_K lparen Condition rparen Statement ELSE_K Statement;
Statement ::= (StatementDoWhile    ) DO_K Statement WHILE_K lparen Condition rparen semicol;
Statement ::= (StatementSwitch     ) SWITCH_K lparen Expr rparen lbrace CaseList rbrace;
Statement ::= (StatementBreak      ) BREAK_K semicol;
Statement ::= (StatementContinue   ) CONTINUE_K semicol;
Statement ::= (StatementReturn     ) RETURN_K semicol;
Statement ::= (StatementReturnExpr ) RETURN_K Expr semicol;
Statement ::= (StatementRead       ) READ_K lparen Designator rparen semicol;
Statement ::= (StatementPrint      ) PRINT_K lparen Expr rparen semicol;
Statement ::= (StatementPrintFormat) PRINT_K lparen Expr comma int_lit rparen semicol;
Statement ::= (StatementScope      ) lbrace StatementList rbrace;

// ident.ident[ expr ] = expr
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// ident.ident[ expr ]++
// ident.ident[ expr ]--
DesignatorStatement ::= (DesignatorStatementAssign    ) Designator Assignop Expr;
DesignatorStatement ::= (DesignatorStatementCall      ) Designator lparen ActPars rparen;
DesignatorStatement ::= (DesignatorStatementPlusplus  ) Designator plusplus;
DesignatorStatement ::= (DesignatorStatementMinusminus) Designator minusminus;



// <epsilon>
// statement statement statement statement
StatementList ::= (StatementListTail ) Statement StatementList;
StatementList ::= (StatementListEmpty) ;

// <epsilon>
// case 1: statement statement statement   case 2: statement statement
CaseList ::= (CaseListTail ) CASE_K int_lit colon StatementList CaseList;
CaseList ::= (CaseListEmpty) ;

// <epsilon>
// expr
// expr, expr, expr
ActPars ::= (ActParsTail ) Expr ActParsNext;
ActPars ::= (ActParsEmpty) ;

ActParsNext ::= (ActParsNextTail ) comma Expr ActParsNext;
ActParsNext ::= (ActParsNextEmpty) ;

// expr   or   expr < expr and expr >= expr  or  expr != expr   // 'and' has greater priority than 'or'!
Condition ::= (ConditionTerm) CondTerm;
Condition ::= (ConditionTail) CondTerm or Condition;

CondTerm ::= (CondTermFact) CondFact;
CondTerm ::= (CondTermTail) CondFact and CondTerm;

CondFact ::= (CondFactExpr) Expr;
CondFact ::= (CondFactTail) Expr Relop Expr;

// term
// +term
// -term
// term + term - term + term
// -term + term - term + term
// +term + term + term + term
// -term + term - term + term ? -term + term : term
Expr ::= (ExprAddition) Addition;
Expr ::= (ExprTernary ) Addition qmark Addition colon Addition;

Addition ::= (AdditionTerm    ) Term;
Addition ::= (AdditionTail    )      SignedAddition;
Addition ::= (AdditionTermTail) Term SignedAddition;

SignedAddition ::= (SignedAdditionTerm) Addop Term;
SignedAddition ::= (SignedAdditionTail) Addop Term SignedAddition;



// factor
// factor*factor*factor
Term ::= (TermFactor) Factor;
Term ::= (TermTail  ) Factor Mulop Term;

// ident.ident[ expr ]
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// 1202 | 'c' | true
// new Object
// new Array[ expr ]
// ( expr )
Factor ::= (FactorDesignator    ) Designator;
Factor ::= (FactorDesignatorCall) Designator lparen ActPars rparen;
Factor ::= (FactorLiteral       ) Literal;
Factor ::= (FactorNewVar        ) NEW_K Type;
Factor ::= (FactorNewArray      ) NEW_K Type lbracket Expr rbracket;
Factor ::= (FactorExpr          ) lparen Expr rparen;

// ident
// ident.ident
// ident[ expr ]
// ident.ident.ident[ expr ].ident
// ident.ident.ident[ expr ].ident[ expr ]
Designator ::= (Designator) ident DesignatorNext;

DesignatorNext ::= (DesignatorNextFieldTail) dot ident              DesignatorNext;
DesignatorNext ::= (DesignatorNextElemTail ) lbracket Expr rbracket DesignatorNext;
DesignatorNext ::= (DesignatorNextEmpty    ) ;



// ident | array[]
VarIdent ::= (VarIdent     ) ident;
VarIdent ::= (VarArrayIdent) ident lbracket rbracket;
// 1202 | 'c' | true
Literal ::= (LiteralInt ) int_lit;
Literal ::= (LiteralChar) char_lit;
Literal ::= (LiteralBool) bool_lit;
// void | type
ReturnType ::= (ReturnTypeVoid) VOID_K;
ReturnType ::= (ReturnType    ) Type;
// int | bool | char | ident
Type ::= (Type) ident;

// =
Assignop ::= (AssignopAssign) assign;
// ==  |  !=  |  >  |  >=  |  <  |  <=
Relop ::= (RelopEq ) eq;
Relop ::= (RelopNeq) neq;
Relop ::= (RelopGt ) gt;
Relop ::= (RelopGeq) geq;
Relop ::= (RelopLt ) lt;
Relop ::= (RelopLeq) leq;
// +  |  -
Addop ::= (AddopPlus ) plus;
Addop ::= (AddopMinus) minus;
// *  |  /  |  %
Mulop ::= (MulopMul ) mul;
Mulop ::= (MulopDiv ) div;
Mulop ::= (MulopPerc) perc;






