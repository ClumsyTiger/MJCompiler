# ________________________________________________________________________________________________________________
# reference materials

# https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-hashtable?view=powershell-7.1
# https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-arrays?view=powershell-7.1
# https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-hashtable?view=powershell-7.1#saving-a-nested-hashtable-to-file
# https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/06-flow-control?view=powershell-7.1
# https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/09-functions?view=powershell-7.1

# https://docs.microsoft.com/en-us/dotnet/api/system.collections.arraylist?view=net-5.0
# https://powershellexplained.com/2017-11-20-Powershell-StringBuilder/
# https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-null?view=powershell-7.1
# https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/remove-item?view=powershell-7.1#example-4--delete-files-in-subfolders-recursively



# ________________________________________________________________________________________________________________
# functions

# find all files with the given extension recursively relative to the current working directory
function Find-Recursive
{
    # this turns a regular function into an advanced function
    [CmdletBinding()]
    # function parameters
    param( [string] $Extension )
    
    # always initialize variables before use (since an exception can occur during assignment)
    $Files = $null;
    # find files with the given extension recursively in the current working directory
    $Files = Get-ChildItem -Path "$PWD" -Include "*$Extension" -File -Recurse;

    # for all files, get the full name from the file info, get the path relative to the current working directory, and finally convert the result to a string
    # +   return an array of such files
    if( $Files ) { @(   $Files.FullName | Resolve-Path -Relative | ForEach-Object -Process { $_.ToString() }   ); }
    else         { @(); }
}



# ________________________________________________________________________________________________________________
# build script

if( "-help" -in $args -or "--help" -in $args )
{
    Write-Output "build   [[-]-help]   [-jflex] [-cup [-ast] [-pst]]   [-clean] [-build]   ([-test ...]|[-run ...])";
    Write-Output "";
    Write-Output "Switches:";
    Write-Output "    --help      shows the help menu";
    Write-Output "    -help       same as --help";
    Write-Output "";
    Write-Output "    -jflex      runs the JFlex tool on the flex specification";
    Write-Output "    -cup        runs the CUP tool on the cup specification";
    Write-Output "      -ast      +   generates the abstract syntax tree using the cup specification";
    Write-Output "      -pst      +   shows the generated parser states";
    Write-Output "";
    Write-Output "    -clean      cleans the project (except files generated by the jflex and cup tools)";
    Write-Output "    -build      builds the project";
    Write-Output "";
    Write-Output "    -test       runs the test program with the given parameters";
    Write-Output "    -run        runs the main program with the given parameters";
    exit 0;
}


# default build script arguments if none specified
if( $args.count -eq 0 )
{
    # leave powershell array constructor ( @() ) if there is only one argument (otherwise it won't be a powershell array)
    $args = @( "-build", "-run" );
}


# jflex tool
if( "-jflex" -in $args )
{
    # always initialize variables before use (since an exception can occur during assignment)
    $BuildCmd = $null;

    # create the build comand array
    $BuildCmd = "java",
        "-cp", "'./MJCompiler/lib/jflex-1.4.3.jar'", "JFlex.Main",
        "-nobak",
        "-d", "'./MJCompiler/src/rs/ac/bg/etf/pp1'",
        "'./MJCompiler/spec/mjlexer.flex'";

    # join the array of strings into a single string separated by spaces
    $BuildCmd = $BuildCmd -Join ' ';


    # print the build command
    Write-Output "---------------------------------------------------------------------------------------------------------------- <<< JFlex"
    Write-Output $BuildCmd

    # invoke the build command
    Invoke-Expression -Command $BuildCmd
}


# cup tool
if( "-cup" -in $args )
{
    # always initialize variables before use (since an exception can occur during assignment)
    $BuildCmd = $null;
    
    # create the build comand array
    # +   relative paths should be relative to the project 'src' folder
    $BuildCmd = "java",
        "-cp", "'../lib/cup_v10k.jar'", "java_cup.Main",
        "-destdir", "'./rs/ac/bg/etf/pp1'",
        "-parser", "'MJParser'",
        "-interface", "-symbols", "'Isym'";

    # build the abstract syntax tree
    if( "-ast" -in $args )
    {
        $BuildCmd += "-ast", "rs.ac.bg.etf.pp1.ast", "-buildtree";
    }

    # show parser states
    if( "-pst" -in $args )
    {
        $BuildCmd += "-dump_states";
    }

    # set the specification file location
    $BuildCmd += "'../spec/mjparser.cup'";

    # join the array of strings into a single string separated by spaces
    $BuildCmd = $BuildCmd -Join ' ';


    # print the build command
    Write-Output "---------------------------------------------------------------------------------------------------------------- <<< CUP"
    Write-Output $BuildCmd


    # join the array of strings into a single string separated by spaces
    $BuildCmd = $BuildCmd -Join ' ';

    # set current working directory to the project 'src' folder, since the ast_cup tool can't find the 'ast' folder otherwise
    Push-Location "./MJCompiler/src";
    # invoke the build command
    Invoke-Expression -Command $BuildCmd
    # restore the previous working directory
    Pop-Location;
}


# build project
if( "-clean" -in $args -or "-build" -in $args )
{
    if( "-clean" -in $args )
    {
        # remove compiled java code
        if( Test-Path "./MJCompiler/bin" -PathType "Container" )
        {
            Remove-Item "./MJCompiler/bin" -Recurse;
        }

        if( Test-Path "./MJCompiler/build" -PathType "Container" )
        {
            Remove-Item "./MJCompiler/build" -Recurse;
        }
        
        if( Test-Path "./MJCompiler/dist" -PathType "Container" )
        {
            Remove-Item "./MJCompiler/dist" -Recurse;
        }

        # remove logs
        if( Test-Path "./MJCompiler/logs" -PathType "Container" )
        {
            Remove-Item "./MJCompiler/logs" -Recurse;
        }

        # remove the generated cup specification files
        Get-ChildItem -Path "./MJCompiler/spec" -Include "*_astbuild.cup" -File -Recurse | Remove-Item;

        # remove all .obj files from the test directory
        # +   When it is used with the Include parameter, the Recurse parameter might not delete all subfolders or all child items. This is a known issue.
        # +   As a workaround, try piping results of the Get-ChildItem -Recurse command to Remove-Item, as described in "Example 4" in this topic.
        Get-ChildItem -Path "./MJCompiler/test" -Include "*.obj" -File -Recurse | Remove-Item;
    }

    if( "-clean" -in $args -and "-build" -in $args )
    {
        $Action = "rebuild clean jar";
    }
    elseif( "-build" -in $args )
    {
        $Action = "build jar";
    }
    elseif( "-clean" -in $args )
    {
        $Action = "clean";
    }

    # always initialize variables before use (since an exception can occur during assignment)
    $BuildCmd = $null;
    # create the build comand array
    $BuildCmd = "ant",
        "-quiet",
        "-f", "./MJCompiler",
        "-Dnb.internal.action.name='$Action'";

    # join the array of strings into a single string separated by spaces
    $BuildCmd = $BuildCmd -Join ' ';


    # print the build command
    Write-Output "---------------------------------------------------------------------------------------------------------------- <<< BUILD"
    Write-Output $BuildCmd

    # clean output from unnecessary info
    $BuildCmd += "|",
        "Select-String", "-NotMatch", "-Pattern", "'\[javadoc\]'";

    # join the array of strings into a single string separated by spaces
    $BuildCmd = $BuildCmd -Join ' ';

    # invoke the build command
    Invoke-Expression -Command $BuildCmd
}



# exit success
exit 0;





