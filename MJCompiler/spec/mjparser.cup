// ________________________________________________________________________________________________
// import section
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


// ________________________________________________________________________________________________
// directive section
parser code {:
	boolean errorDetected = false;
	Logger logger = Logger.getLogger( getClass() );
   
    // redefine cup parser methods for error reporting
    public void report_fatal_error( String message, Object info ) throws java.lang.Exception
    {
        done_parsing();
        report_error( message, info );
    }
  
    // redefine cup parser methods for error reporting
    public void syntax_error( Symbol cur_token )
    {
        report_error( "\nSintaksna greska", cur_token );
    }
  
    // redefine cup parser methods for error reporting
    public void unrecovered_syntax_error( Symbol cur_token ) throws java.lang.Exception
    {
        report_fatal_error( "Fatalna greska, parsiranje se ne moze nastaviti", cur_token );
    }

    // redefine cup parser methods for error reporting
    public void report_error( String message, Object info )
    {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder( message );

    	if( info instanceof Symbol )
        {
            msg.append( " na liniji " ).append( ( ( Symbol )info ).left );
        }

        logger.error( msg.toString() );
    }
    
    // redefine cup parser methods for error reporting
    public void report_info( String message, Object info )
    {
    	StringBuilder msg = new StringBuilder( message ); 

    	if( info instanceof Symbol )
        {
            msg.append( " na liniji " ).append( ( ( Symbol )info ).left );
        }

        logger.info( msg.toString() );
    }
    
:}

scan with {:
	Symbol symbol = this.getScanner().next_token();
	if( symbol != null && symbol.value != null )
    {
		logger.info( symbol.toString() + " " + symbol.value.toString() );
    }

	return symbol;
:}





// ________________________________________________________________________________________________
// language characters


// keywords [terminals]
terminal PROGRAM_K, CLASS_K, /*ENUM_K,*/ EXTENDS_K;   // enum currently not used
terminal CONST_K, VOID_K;
terminal IF_K, ELSE_K, SWITCH_K, CASE_K, BREAK_K, CONTINUE_K, RETURN_K;
terminal DO_K, WHILE_K;
terminal NEW_K, PRINT_K, READ_K;

// operators [terminals]
//       +     -      *    /    %
terminal plus, minus, mul, div, perc;
//       ==  !=   >   >=   <   <=   &&   ||
terminal eq, neq, gt, geq, lt, leq, and, or;
//       =       ++        --
terminal assign, plusplus, minusminus;
//       ;        ,      .    {       }       (       )       [         ]         ?      :
terminal semicol, comma, dot, lbrace, rbrace, lparen, rparen, lbracket, rbracket, qmark, colon;

// literals [terminals]
terminal Integer int_lit;      // 0   10   12012
terminal Boolean bool_lit;     // true   false
terminal Character char_lit;   // 'a'   '-'

// identifiers [terminals]
terminal String ident;         // asdf0_13



// declarations [nonterminals]
nonterminal Program, StaticDeclList, StaticDecl;
nonterminal ClassDecl, ClassDeclScope, MethodDeclScope, MethodDeclList;
nonterminal MethodDecl, FormPars, FormParsNext, VarDeclList;
nonterminal VarDecl, VarIdentList;
nonterminal ConstDecl, IdentInitList;

// statement parts [nonterminals]
nonterminal Statement, DesignatorStatement;
nonterminal StatementList, CaseList, ActPars, ActParsNext;
nonterminal Condition, CondTerm, CondFact;
nonterminal Expr, Addition, SignedTermNext;
nonterminal Term, Factor;
nonterminal Designator, DesignatorNext;

// types, literals, operators [nonterminals]
nonterminal VarIdent, Literal, ReturnType, Type;
nonterminal Assignop, Relop, Addop, Mulop;



// associativity [terminals]
precedence left ELSE_K;        // left associative operation => 'else' is paired with the closest left 'if'

// starting non-terminal
start with Program;




// ________________________________________________________________________________________________
// language rules


// program ident { }
// program ident { method method method }
// program ident constdl constdl vardl vardl classdl { }
// program ident constdl constdl vardl vardl classdl { method method method }
Program ::= PROGRAM_K ident StaticDeclList MethodDeclScope;

// <epsilon>
// constdl constdl vardl vardl classdl
StaticDeclList ::= StaticDecl StaticDeclList;
StaticDeclList ::= ;

StaticDecl ::= ConstDecl | VarDecl | ClassDecl;



// class A { }
// class A { { method method method } }
// class A extends B { vardl vardl vardl vardl }
// class A extends B { vardl vardl vardl vardl { method method method } }
ClassDecl ::= CLASS_K ident ClassDeclScope;
ClassDecl ::= CLASS_K ident EXTENDS_K Type ClassDeclScope;

// { }
// { { method method method } }
// { vardl vardl vardl vardl }
// { vardl vardl vardl vardl { method method method } }
ClassDeclScope ::= lbrace VarDeclList rbrace;
ClassDeclScope ::= lbrace VarDeclList MethodDeclScope rbrace;

// { }
// { method method method }
MethodDeclScope ::= lbrace MethodDeclList rbrace;

MethodDeclList ::= MethodDecl MethodDeclList;
MethodDeclList ::= ;



// void foo() { }
// void foo() { statement statement }
// void foo() vardl vardl { }
// void foo() vardl vardl { statement statement }
// void foo( int a, char c, Node Array[] ) { }
// void foo( int a, char c, Node Array[] ) { statement statement }
// void foo( int a, char c, Node Array[] ) vardl vardl { }
// void foo( int a, char c, Node Array[] ) vardl vardl { statement statement }
MethodDecl ::= ReturnType ident lparen FormPars rparen VarDeclList lbrace StatementList rbrace;

// <epsilon>
// int ident, Node Array[], char c
FormPars ::= Type VarIdent FormParsNext;
FormPars ::= ;

FormParsNext ::= comma Type VarIdent FormPars;
FormParsNext ::= ;

// <epsilon>
// vardl vardl vardl vardl
VarDeclList ::= VarDecl VarDeclList;
VarDeclList ::= ;



// int a, b[], c;
// A a1, a2;
VarDecl ::= Type VarIdentList semicol;

VarIdentList ::= VarIdent;
VarIdentList ::= VarIdent comma VarIdentList;



// const int a = 5, b = 6, c = 11;
ConstDecl ::= CONST_K Type IdentInitList semicol;

IdentInitList ::= ident Assignop Literal;
IdentInitList ::= ident Assignop Literal comma IdentInitList;



// ident.ident[ expr ] = expr;
// ident.ident[ expr ]( );
// ident.ident[ expr ]( expr, expr, expr );
// ident.ident[ expr ]++;
// ident.ident[ expr ]--;
//
// if( condition ) statement
// if( condition ) statement else statement
// do statement while( condition );
// switch( expr ) { }
// switch( expr ) { case 1: statement statement statement   case 2: statement statement }
// break;
// continue;
// return;
// return expr;
//
// read( ident.ident[ expr ] );
// print( ident.ident[ expr ], 2 );
//
// {}
// { statement statement statement }
Statement ::= DesignatorStatement semicol;
Statement ::= IF_K lparen Condition rparen Statement;
Statement ::= IF_K lparen Condition rparen Statement ELSE_K Statement;
Statement ::= DO_K Statement WHILE_K lparen Condition rparen semicol;
Statement ::= SWITCH_K lparen Expr rparen lbrace CaseList rbrace;
Statement ::= BREAK_K semicol;
Statement ::= CONTINUE_K semicol;
Statement ::= RETURN_K semicol;
Statement ::= RETURN_K Expr semicol;
Statement ::= READ_K lparen Designator rparen semicol;
Statement ::= PRINT_K lparen Expr rparen semicol;
Statement ::= PRINT_K lparen Expr comma int_lit rparen semicol;
Statement ::= lbrace StatementList rbrace;

// ident.ident[ expr ] = expr
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// ident.ident[ expr ]++
// ident.ident[ expr ]--
DesignatorStatement ::= Designator Assignop Expr;
DesignatorStatement ::= Designator lparen ActPars rparen;
DesignatorStatement ::= Designator plusplus;
DesignatorStatement ::= Designator minusminus;



// <epsilon>
// statement statement statement statement
StatementList ::= Statement StatementList;
StatementList ::= ;

// <epsilon>
// case 1: statement statement statement   case 2: statement statement
CaseList ::= CASE_K int_lit colon StatementList CaseList;
CaseList ::= ;

// <epsilon>
// expr
// expr, expr, expr
ActPars ::= Expr ActParsNext;
ActPars ::= ;

ActParsNext ::= comma Expr ActParsNext;
ActParsNext ::= ;

// expr   or   expr < expr and expr >= expr  or  expr != expr   // 'and' has greater priority than 'or'!
Condition ::= CondTerm;
Condition ::= CondTerm or Condition;

CondTerm ::= CondFact;
CondTerm ::= CondFact and CondTerm;

CondFact ::= Expr;
CondFact ::= Expr Relop Expr;

// term
// +term
// -term
// term + term - term + term
// -term + term - term + term
// +term + term + term + term
// -term + term - term + term ? -term + term : term
Expr ::= Addition;
Expr ::= Addition qmark Addition colon Addition;

Addition ::= Term;
Addition ::=      SignedTermNext;
Addition ::= Term SignedTermNext;

SignedTermNext ::= Addop Term;
SignedTermNext ::= Addop Term SignedTermNext;



// factor
// factor*factor*factor
Term ::= Factor;
Term ::= Factor Mulop Term;

// ident.ident[ expr ]
// ident.ident[ expr ]( )
// ident.ident[ expr ]( expr, expr, expr )
// 1202 | 'c' | true
// new Object
// new Array[ expr ]
// ( expr )
Factor ::= Designator;
Factor ::= Designator lparen ActPars rparen;
Factor ::= Literal;
Factor ::= NEW_K Type;
Factor ::= NEW_K Type lbracket Expr rbracket;
Factor ::= lparen Expr rparen;

// ident
// ident.ident
// ident[ expr ]
// ident.ident.ident[ expr ].ident
// ident.ident.ident[ expr ].ident[ expr ]
Designator ::= ident DesignatorNext;

DesignatorNext ::= dot ident              DesignatorNext;
DesignatorNext ::= lbracket Expr rbracket DesignatorNext;
DesignatorNext ::= ;



// ident | array[]
VarIdent ::= ident;
VarIdent ::= ident lbracket rbracket;
// 1202 | 'c' | true
Literal ::= int_lit | char_lit | bool_lit;
// void | type
ReturnType ::= VOID_K | Type;
// int | bool | char | ident
Type ::= ident;

// =
Assignop ::= assign;
// ==  |  !=  |  >  |  >=  |  <  |  <=
Relop ::= eq | neq | gt | geq | lt | leq;
// +  |  -
Addop ::= plus | minus;
// *  |  /  |  %
Mulop ::= mul | div | perc;






// terminal PROG, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, PRINT, RETURN, PLUS, EQUAL, VOID;
// terminal Integer NUMBER ;
// terminal String IDENT ;
// terminal IF, ELSE;

// nonterminal MethodDeclList, VarDecl;
// nonterminal FormalParamList, FormalParamDecl, FormPars, ActualPars, ActualParamList; 
// nonterminal StatementList, Statement, Addop;
// nonterminal Unmatched, Matched;

// nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName; 
// nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Factor, VarDeclList; 

// Program ::= (Program) PROG ProgName:p VarDeclList LBRACE MethodDeclList RBRACE 
// ;

// ProgName ::= (ProgName) IDENT:pName 
// ;

// VarDeclList ::= (VarDeclarations) VarDeclList VarDecl  
// 				|
// 				(NoVarDecl)/* epsilon */ 
// 				;
				
// VarDecl ::= (VarDecl) Type:varType IDENT:varName SEMI 
// ;

// Type ::= (Type) IDENT:typeName 
// ;

// MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
// 					|
// 					(NoMethodDecl)/* epsilon */
// 					;

// MethodDecl ::= (MethodDecl) MethodTypeName
// 			   LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE 
// 			   ;

// MethodTypeName ::= (MethodTypeName) Type:retType IDENT:methName
// ;

// FormPars ::= (FormParams) FormalParamList | (NoFormParam) /* epsilon */ ;

// FormalParamList ::= (FormalParamDecls) FormalParamList COMMA FormalParamDecl
// 					|
// 					(SingleFormalParamDecl) FormalParamDecl
// 					;
					
// FormalParamDecl ::= (FormalParamDecl) Type IDENT ;

// StatementList ::= (Statements) StatementList Statement 
// 					|
// 				  (NoStmt) /* epsilon */
// 				  ;

// Statement ::= (MatchedStmt) Matched | (UnmachedStmt) Unmatched ;

// Unmatched ::= (UnmatchedIf) IF Expr Statement | (UnmatchedIfElse) IF Expr Matched ELSE Unmatched;
	
				  
// Matched ::= (Assignment) Designator:dest EQUAL Expr:e SEMI 
// 			  |
// 			  (ErrAssignment) Designator EQUAL error SEMI
// 			  {: parser.log.debug("Uspesan oporavak od greske pri dodeli vrednosti."); :}
// 			  |
// 			  (PrintStmt) PRINT LPAREN Expr RPAREN SEMI 
// 			  |
// 			  (ReturnExpr) RETURN Expr:t SEMI
// 			  |
// 			  (ReturnNoExpr) RETURN SEMI
// 			  | 
// 			  (MatchedIf) IF Expr Matched ELSE Matched
// 			  |
// 			  (ProcCall) Designator:func LPAREN ActualPars RPAREN SEMI
// 			  ;
			  
// Expr ::= (AddExpr) Expr:te Addop Term:t
// 		 |
// 		 (TermExpr) Term:t
// 		 ;

// Term ::= (Term) Factor:t 
// ;

// Factor ::= (Const) NUMBER
// 			|
// 		   (Var) Designator:d
// 		    |
// 		   (FuncCall) Designator:func LPAREN ActualPars RPAREN
// 		   ;

// ActualPars ::= (Actuals) ActualParamList 
// 				| 
// 			   (NoActuals) /* epsilon */ 
// 			   ;
			   
// ActualParamList ::= (ActualParams) ActualParamList COMMA Expr
// 					|
// 					(ActualParam) Expr
// 					;

// Designator ::= (Designator) IDENT:name
// ;

// Addop ::= (Addop) PLUS ;
